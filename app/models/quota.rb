# This describes disk quota utilization for a given user and volume
class Quota
  # Type of quota this object describes
  # @return [Symbol] type of quota
  attr_reader :type

  # Path to volume
  # @return [Pathname] path to volume
  attr_reader :path

  # User utilizing disk resources under this volume
  # @return [String] user name
  attr_reader :user

  # Disk space used by user for this volume
  # @return [Integer] blocks used by user
  attr_reader :user_block_usage

  # Disk space used by all users this quota encompasses for this volume
  # @return [Integer] total blocks used
  attr_reader :total_block_usage

  # Disk space limit set for this volume
  # @return [Integer] block limit
  attr_reader :block_limit

  # Number of files owned by user for this volume
  # @return [Integer] files owned by user
  attr_reader :user_file_usage

  # Number of files owned by all users this quota encompasses for this volume
  # @return [Integer] total files owned
  attr_reader :total_file_usage

  # Number of files limit set for this volume
  # @return [Integer] file limit
  attr_reader :file_limit

  # When this quota report was generated by the file system
  # @return [Time] when quota generated
  attr_reader :updated_at

  # Number of files allowed over limit
  # @return [Integer] file grace
  attr_reader :file_grace

  # Number of blocks allowed over limit
  # @return [Integer] disk grace
  attr_reader :disk_grace

  class << self
    # Get quota objects for all users in JSON file(s)
    def all(opts = {})
      find(nil, opts)
    end

    # Get quota objects only for requested user in JSON file(s)
    def find(quota_paths, user, opts = {})
      user  = user && user.to_s
      opts  = opts.to_h.compact.symbolize_keys
      paths = Array.wrap(quota_paths).map { |p| Pathname.new p }
      logger = opts.fetch(:logger, Rails.logger)

      quotas = []
      paths.each do |path|
        json = Oj.strict_load(path.read)
        case json["version"].to_i
        when 0..1
          quotas += find_v1(user, json)
        else
          logger.error("Invalid version specified for quota file: '#{path}'")
        end
      end
      quotas
    end

    private
      # Parse JSON object using version 1 formatting
      def find_v1(user, params)
        q = []
        time = params["timestamp"]
        params["quotas"].each do |quota|
          q << Quota.new(quota.merge "updated_at" => time) if !user || user == quota["user"]
        end
        q
      end
  end

  # @param params [#to_h] list of parameters that define quota object
  # @option params [#to_sym] :type (:user) type of quota
  # @option params [#to_s] :path path to volume
  # @option params [#to_s] :user user name
  # @option params [#to_i] :block_usage (total_block_usage) blocks used by user
  # @option params [#to_i] :total_block_usage total blocks used
  # @option params [#to_i] :block_limit block limit
  # @option params [#to_i] :file_usage (total_file_usage) files owned by user
  # @option params [#to_i] :total_file_usage total files owned
  # @option params [#to_i] :file_limit file limit
  # @option params [#to_i] :updated_at when quota generated
  def initialize(params)
    params = params.to_h.compact.symbolize_keys

    @type = params.fetch(:type, :user).to_sym
    @path = Pathname.new(params.fetch(:path).to_s)
    @user = params.fetch(:user).to_s    # FIXME: Can be integer in rare cases
    @block_limit = params.fetch(:block_limit).to_i
    @file_limit  = params.fetch(:file_limit).to_i
    @total_block_usage = params.fetch(:total_block_usage).to_i
    @total_file_usage  = params.fetch(:total_file_usage).to_i
    @user_block_usage = params.fetch(:block_usage, @total_block_usage).to_i
    @user_file_usage  = params.fetch(:file_usage, @total_file_usage).to_i
    @updated_at = Time.at(params.fetch(:updated_at).to_i)
    @file_grace = params.fetch(:file_grace, 0).to_i # future functionality
    @disk_grace = params.fetch(:disk_grace, 0).to_i # future functionality
  end

  # Whether quota reporting is shared for this volume amongst other users
  # @return [Boolean] is quota for this volume shared
  def shared?
    type != :user
  end

end
